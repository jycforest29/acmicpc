### boj 1475

```python
import sys
input = sys.stdin.readline

n = int(input())
d = dict()
for i in range(10):
    d[i] = 0

while n > 0:
    d[n % 10] += 1
    n //= 10

if max(d.values()) == 1:
    print(1)
else:
    if d[6] > 1 or d[9] > 1:
        t = (d[6]+d[9]) // 2 if (d[6]+d[9]) % 2 == 0 else (d[6]+d[9]) // 2 + 1
        d[6] = 0
        d[9] = 0
        print(max(t, max(d.values())))
    else:
        print(max(d.values()))
```

- 기억에 의존한 풀이를 해선 안되는 이유가 이 문제에 명확하게 들어있음.
    - 이전에 풀었던 깔끔한 중복체크 로직이 있을 것이라 생각해 시간 지체
        - 중복체크 로직
            
            ```python
            d = dict()
            for i in range(10):
                d[i] = 0
            
            while n > 0:
                d[n % 10] += 1
                n //= 10
            ```
            
            - 다른 사람 로직
                
                ```python
                위와 비슷. 특별히 엄청 효율적인 로직은 없는듯.
                ```
                
            
            **→ 기출이 나오는 것이 아니기에 내가 지금 아는 가장 효율적인 풀이로 짜야함**
            
    - 홀/짝 구분(틀린 이유)
        
        ```python
        if d[6] > 1 or d[9] > 1:
            t = (d[6]+d[9]) // 2 if (d[6]+d[9]) % 2 == 0 else (d[6]+d[9]) // 2 + 1
            d[6] = 0
            d[9] = 0
            print(max(t, max(d.values())))
        ```
        
        처음에 **t = (d[6]+d[9]) // 2로 풀어서 틀림**
        
        결국 문제의 조건을 이해했으나, 철저하게 적용하지 못한것임.
        
        왜 못했을까? 다시 풀면 실버 5인데 틀릴까봐 무서워서, 대강 저번에 이렇게 풀었었지라고 생각하고 비슷한 로직만 짜니까 틀린거 아닐까?
        
        **→ 이런식으로 풀면 이렇게 다시 푸는거 시간낭비임. 다시 푸는 이유는 예전과 다르게 로직을 얼마나 빠르고 근거에 입각해 논리적으로 짜는지 확인하려고 푸는거임. 제대로 풀자.**
