문제 유형 예시
거스름돈 문제
    =>가지고 있는 화폐의 단위 중 큰 단위가 항상 작은 동전의 배수이므로 성립.
    화폐의 종류만큼만 반복을 수행하므로 O(N). 거슬러줘야 하는 금액과 무관하며 동전 종류에만 영향을 받음.
1이 될때까지
    =>n의 값을 줄일 때 2이상의 수로 나누는 작업이 1을 빼는 작업보다 훨씬 n을 줄일 수 있기 때문, n이 항상 1로 수렴
    while True:
        <!-- k로 나누어 떨어지는 수까지 1 빼주기 -->
        target = (n // k)*k
        result += (n-target)
        n = target
        <!-- <인 이유는 <=인 경우 나누어 떨어지기 때문 -->
        if n < k:
            break
        <!-- k로 나누기 -->
        result += 1
        n //= k
    <!-- n 자체를 변경했기에 -->
    result += (n-1)
    코드를 위와 같이 작성할 경우 시간 복잡도가 로그로 줄어듬
모험가 길드
    =>그룹수의 최대는 그룹내 인원수의 최소임. 따라서 공포도가 작은것부터.
    for i in data:
        count += 1
        if count >= i:
            result += 1
            count = 0
